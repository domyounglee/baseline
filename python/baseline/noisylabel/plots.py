import numpy as np
import pickle
import pandas as pd
import seaborn as sn
import matplotlib.pyplot as plt
from utilities import softmax, unitNorm
np.set_printoptions(suppress=True)


class plotting(object):
	# This object if ro analysing the output files generated by the training process

	def __init__(self, filename, noiselvls, noisemodels, n_cls, optag=''):
		# noisemodels: all the noisemodelconda working with
		self.filename = filename
		self.noiselvl = noiselvls
		if type(noisemodels) == str:
			self.noisemodel = [noisemodels]
		else:
			self.noisemodel = noisemodels
		self.n_cls = n_cls
		self.optag = optag

	def readWeights(self, noiselvl, noisemodel, isSoftmax=False, isPlot=False):
		"""
		type(noiselvl) = float
		type(noisemodel) = str
		typr(isSoftmax) = bool; default = False; If true retuns softmax of weight amtrix along with
		weight matrix itself
		Read last layer weight matrix of a given noiselvl(noise level) and noisemodel(noise model)
		Return weight matrix and plot if defined
		"""
		if noisemodel == 'WoNM':
			print('This model is without noise model. No weight matrix')
			return
		fileName = self.filename+str(int(noiselvl*100)) + self.optag
		weight_dict = pickle.load(open(fileName, 'rb'))
		weight_matrix = np.around(weight_dict[noisemodel], decimals=3)
		if isPlot:
			plt.figure()
			if isSoftmax:
				df_cm = pd.DataFrame(softmax(weight_matrix), range(self.n_cls), range(self.n_cls))
				plt.title("(Softmaxed) Weight matrix for ("+noisemodel+", "+str(noiselvl)+" )")
			else:
				df_cm = pd.DataFrame(weight_matrix, range(self.n_cls), range(self.n_cls))
				plt.title("Weight matrix for ("+noisemodel+", "+str(noiselvl)+" )")
			sn.set(font_scale=1.4)  # for label size
			cmap = sn.cubehelix_palette(50, hue=0.05, rot=0, light=0.9, dark=0, as_cmap=True)
			sn.heatmap(df_cm, annot=True,annot_kws={"size": 12}, cmap=cmap)  # font size
			plt.ylabel("Noisy label prediction")
			plt.xlabel("True label prediction")
			plt.show()
		if isSoftmax:
			return weight_matrix, softmax(weight_matrix)
		else:
			return weight_matrix, None

	def allAccuracies(self, std=False):
		"""
		type(std) = bool; defines if trial variance need to be calculated. default=False
		Returns a matrix of all the accuracies in which rows corresponds to the noise level
		and columns corresponds to the nois emodel
		"""
		accuraciesA = np.zeros([len(self.noiselvl), len(self.noisemodel)])
		stdA = np.zeros([len(self.noiselvl), len(self.noisemodel)])
		i = 0
		for noise_per in self.noiselvl:
			# print(noise_per)
			j = 0
			fileName = self.filename + str(int(noise_per*100)) + self.optag
			weight_dict = pickle.load(open(fileName, 'rb'))
			# print(weight_dict)
			for Nmodel in self.noisemodel:
				accuraciesA[i, j] = np.around(np.mean(weight_dict[Nmodel+'accuracies']), decimals=2)
				stdA[i, j] = np.around(np.std(weight_dict[Nmodel+'accuracies']), decimals=2)
				j = j+1
			i = i+1
		# print("Noise Levels: ", self.noiselvl)
		# print('Classification Accuracies')
		# print(accuraciesA)
		if std:
			return accuraciesA, stdA
		else:
			return accuraciesA, None

	def allF1Scores(self, std=None):
		"""
		type(std) = bool; defines if trial variance need to be calculated. default=False
		Returns a matrix of all the F1 Scores in which rows corresponds to the noise level
		and columns corresponds to the nois emodel
		"""
		f1_scoresA = np.zeros([len(self.noiselvl), len(self.noisemodel)])
		stdA = np.zeros([len(self.noiselvl), len(self.noisemodel)])
		i = 0
		for noise_per in self.noiselvl:
			# print(noise_per)
			j = 0
			fileName = self.filename + str(int(noise_per*100)) + self.optag
			weight_dict = pickle.load(open(fileName, 'rb'))
			# print(weight_dict)
			for Nmodel in self.noisemodel:
				f1_scoresA[i, j] = np.around(np.mean(weight_dict[Nmodel+'f1_scores']), decimals=4)
				stdA[i, j] = np.std(weight_dict[Nmodel+'f1_scores'])
				j = j+1
			i = i+1
		# print("Noise Levels: ", self.noiselvl)
		# print('F1 Scores')
		# print(f1_scoresA)
		if std:
			return f1_scoresA, stdA
		else:
			return f1_scoresA, None

	def plotAllWeights(self, isSoftmax=False):
		"""
		Plot all the weights at once for better visualization
		type(isSoftmax) = bool; default= False; if true plot the softmaxed weights except
		for the input distribution
		"""
		if isSoftmax:
			print('Showing Softmax of weight matrices except for the out_dist--Input noise distribution')
		plt.figure(figsize=(30, 30))
		if (len(self.noisemodel) == 1) and (self.noisemodel != "WoNM"):
			Nmodels = self.noisemodel[:]
		elif  self.noisemodel == "WoNM":
			Nmodels[0] = 'out_dist'
		else:
			Nmodels[0] = 'out_dist'
		print(Nmodels)
		ind = 0
		for n_lvl in self.noiselvl:
			for n_model in Nmodels:

				weight, softweight = self.readWeights(n_lvl, n_model, isSoftmax)
				if isSoftmax:
					if ind % len(Nmodels) == 0:
						ind = ind+1
						df_cm = pd.DataFrame(np.around(weight, decimals=2), range(self.n_cls), range(self.n_cls))
					else:
						ind = ind+1
						df_cm = pd.DataFrame(softweight, range(self.n_cls), range(self.n_cls))
				else:
					ind = ind+1
					df_cm = pd.DataFrame(weight, range(self.n_cls), range(self.n_cls))

				plt.subplot(len(self.noiselvl), len(self.noisemodel), ind)
				sn.set(font_scale=1.4)  # for label size
				cmap = sn.cubehelix_palette(50, hue=0.05, rot=0, light=0.9, dark=0, as_cmap=True)
				sn.heatmap(df_cm, annot=True, annot_kws={"size": 12}, cmap=cmap)  # font size
				if ind % len(Nmodels) == 1:
					plt.ylabel(n_lvl)
				if ind <= len(Nmodels):
					plt.title(n_model)
		plt.show()
		return


	def plotAccMat(self, NoiseModelCode, ErrorPlot=False):
		"""
		Plot accuracies for all the noise levels and their corresponding noisemodels
		"""

		plt.figure(figsize=(len(self.noiselvl), len(self.noisemodel)))
		if not ErrorPlot:
			accuraciesA, _ = self.allAccuracies(std=False)
			for i in range(len(self.noisemodel)):
				plt.plot(np.array(self.noiselvl), accuraciesA[:, i],
						 label=self.noisemodel[i],
						 color=NoiseModelCode[self.noisemodel[i]]['color'],
						 marker=NoiseModelCode[self.noisemodel[i]]['marker'])
		else:
			accuraciesA, accstd = self.allAccuracies(std=True)
			for i in range(len(self.noisemodel)):
				plt.errorbar(np.array(self.noiselvl), accuraciesA[:, i], accstd[:, i],
							 label=self.noisemodel[i],
							 color=NoiseModelCode[self.noisemodel[i]]['color'],
							 marker=NoiseModelCode[self.noisemodel[i]]['marker'])

		plt.legend()
		plt.ylabel('Classification Accuracy')
		plt.xlabel('Noise Percentage')
		plt.title('Classification Accuracies')
		# plt.title( Dataset+' Clean data Accuracy = %.2f' % accuraciesA[0,0])
		# plt.title(Dataset+' Random Noise '+ plateform)
		# plt.ylim([80, 100])
		# 'Trec Clean data Accuracy = %.2f' % accuraciesA[0,0],
		plt.grid()
		plt.show()
		return

	def plotF1Mat(self, NoiseModelCode, ErrorPlot=False):
		"""
		Plot F1 Scires for all the noise levels and their corresponding noisemodels
		"""

		plt.figure(figsize=(len(self.noiselvl), len(self.noisemodel)))
		if not ErrorPlot:
			accuraciesA, _ = self.allF1Scores(std=False)
			for i in range(len(self.noisemodel)):
				plt.plot(np.array(self.noiselvl), accuraciesA[:, i],
						 label=self.noisemodel[i],
						 color=NoiseModelCode[self.noisemodel[i]]['color'],
						 marker=NoiseModelCode[self.noisemodel[i]]['marker'])
		else:
			accuraciesA, accstd = self.allF1Scores(std=True)
			for i in range(len(self.noisemodel)):
				plt.errorbar(np.array(self.noiselvl), accuraciesA[:, i], accstd[:, i],
							 label=self.noisemodel[i],
							 color=NoiseModelCode[self.noisemodel[i]]['color'],
							 marker=NoiseModelCode[self.noisemodel[i]]['marker'])

		plt.legend()
		plt.ylabel('F1 Scores')
		plt.xlabel('Noise Percentage')
		plt.title('F1 Scores')
		# plt.title( Dataset+' Clean data Accuracy = %.2f' % accuraciesA[0,0])
		# plt.title(Dataset+' Random Noise '+ plateform)
		# plt.ylim([80, 100])
		# 'Trec Clean data Accuracy = %.2f' % accuraciesA[0,0],
		plt.grid()
		plt.show()
		return


if __name__ == '__main__':
	import numpy as np
	import os
	import json
	import matplotlib.pyplot as plt

	Backend = 'pytorch'
	# Backend = 'keras'
	with open('Noise_model_pySST2.json') as f:
		jdata = json.load(f)
	noisemodels = list(jdata.keys())

	NoiseModelCode = {'WoNM': {'color': 'b', 'marker': 'o'},
						'NMWoRegu': {'color': 'g', 'marker': 'v'},
						'NMwRegu001': {'color': 'r', 'marker': 'x'},
						'NMwRegu01': {'color': 'c', 'marker': 's'},
						'TDwRegu01': {'color': 'm', 'marker': 'd'},
						'RDwRegu01': {'color': [0.4, 0.2, 0.1], 'marker': 'o'},
						'NMwl1Regu001': {'color': 'k', 'marker': '.'},
						'NMwl1l2Regu001': {'color': [0.3, 0.5, 0.6], 'marker': 'X'},
						'NMwl1l2Regu0': {'color': [0.7, 0.2, 0.3], 'marker': '.'}}

	# Dataset = 'trec'
	# n_cls = 6
	# noise_input = [0.0,  0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7] #,0.4, 0.5, 0.6, 0.7
	# path = '/home/ijindal/dev/work/3csi-rd/ijindal/trec_results/'
	# # path = '/home/ijindal/dev/work/Noisy_model_learning/trec/'
	# rand = 'Rand'
	# Batchsz = ['B10', 'B50']
	# optag = ''


	# Dataset = 'SST2'
	# n_cls = 2
	# noise_input = [0.0, 0.1, 0.2, 0.3, 0.4, 0.47, 0.5]
	# path = '/home/ijindal/dev/work/3csi-rd/ijindal/SST2_Results/'
	# rand = ''
	# Batchsz = ['B50','B100','B300' ]
	# optag = ''

	Dataset = 'AG'
	n_cls = 4
	noise_input = [0.3]
	# noise_input = [0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7]
	path = '/home/ijindal/dev/work/3csi-rd/ijindal/AG/'
	rand = 'Rand'
	Batchsz = ['B100', 'B1024']
	optag = ''


	# Dataset = 'dbpedia'
	# n_cls = 14
	# noise_input = [0.0, 0.3, 0.5, 0.7, 0.75, 0.8, 0.85, 0.9]
	# path = '/home/ijindal/dev/work/3csi-rd/ijindal/dbpedia_results//'
	# rand = 'Rand'
	# Batchsz = ['B512','B1024']
	# optag = ''

	# Dataset = 'vfg1_1'
	# n_cls = 48
	# noise_input = [0.0] #,0.4, 0.5, 0.6, 0.7
	# path = '/home/ijindal/dev/work/3csi-rd/ijindal/vfg1_1/'
	# # path = '/home/ijindal/dev/work/Noisy_model_learning/trec/'
	# rand = ''
	# Batchsz = ['B512', 'B50']

	# Dataset = 'subcat-0418-clean'
	# n_cls = 5
	# noise_input = [0.0]
	# path = '/home/ijindal/dev/work/3csi-rd/ijindal/subcat-0418-clean/'
	# rand = ''
	# Batchsz = ['B512']
	# optag = 'skew5'

	# Dataset = 'amzProd'
	# n_cls = 23
	# noise_input = [0.0, 0.1, 0.3, 0.5, 0.6, 0.7, 0.8, 0.85, 0.9]
	# path = '/home/ijindal/dev/work/3csi-rd/ijindal/amz_prod/'
	# rand = ''
	# Batchsz = ['B1024']
	# optag = ''




	noisemodels = list(jdata.keys())[0:-5]
	print(noisemodels)

	file_id = os.path.join(path, Dataset + '_' + Batchsz[0] + 'Everything'+rand + Backend)

	output = plotting(filename=file_id, noiselvls=noise_input, noisemodels=noisemodels, n_cls=n_cls, optag=optag)

	# f1_scoresA, f1std = output.allF1Scores(std=True)
	accuraciesA, accstd = output.allAccuracies(std=True)
	print(noisemodels)

	output.plotAccMat(NoiseModelCode,ErrorPlot=True)
	# output.plotF1Mat(NoiseModelCode)
	print(accuraciesA)
	print(accstd)
	# plt.title(Dataset+' '+rand+' Noise plot '+ Backend)

	# weight, softweigh= output.readWeights(noiselvl=0.5, noisemodel='NMwRegu01', isSoftmax=False, isPlot=True)
	# print(weight)

	weight, softweigh= output.readWeights(noiselvl=0.3, noisemodel='out_dist', isSoftmax=True, isPlot=False)



	output.plotAllWeights(isSoftmax=False)







